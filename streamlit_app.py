
# Streamlit app with URL-based login persistence
# ----------------------------------------------
# This version uses st.query_params to persist login state across refreshes.

import streamlit as st
import numpy as np
import trimesh
import tempfile
import os

# ------------------- Password gate -------------------
PASSWORD = "changeme"

params = st.experimental_get_query_params()
if params.get("auth", ["0"])[0] != "1":
    st.title("🔒 비밀번호 입력")
    pwd = st.text_input("비밀번호를 입력하세요", type="password")
    if st.button("로그인"):
        if pwd == PASSWORD:
            st.success("✅ 로그인 성공!")
            st.experimental_set_query_params(auth="1")
            st.experimental_rerun()
        else:
            st.error("❌ 비밀번호가 틀렸습니다.")
    st.stop()

# ------------------- Main App ------------------------
st.title("🛠️ STL → G‑code (Streamlit)")

def trim_segment_end(segment, trim_distance=30.0):
    segment = np.array(segment)
    total_len = np.sum(np.linalg.norm(np.diff(segment, axis=0), axis=1))
    if total_len <= trim_distance:
        return segment
    trimmed = [segment[0]]
    acc = 0.0
    for i in range(1, len(segment)):
        p1, p2 = segment[i - 1], segment[i]
        d = np.linalg.norm(p2 - p1)
        if acc + d >= total_len - trim_distance:
            r = (total_len - trim_distance - acc) / d
            trimmed.append(p1 + (p2 - p1) * r)
            break
        trimmed.append(p2)
        acc += d
    return np.array(trimmed)

def simplify_segment(segment, min_dist):
    simplified = [segment[0]]
    for pt in segment[1:-1]:
        if np.linalg.norm(pt[:2] - simplified[-1][:2]) >= min_dist:
            simplified.append(pt)
    simplified.append(segment[-1])
    return np.array(simplified)

def shift_to_nearest_start(segment, ref_point):
    idx = np.argmin(np.linalg.norm(segment[:, :2] - ref_point, axis=1))
    return np.concatenate([segment[idx:], segment[1:idx + 1]], axis=0), segment[idx]

def generate_gcode(mesh,
                   z_int        = 30.0,
                   feed         = 2000,
                   ref_pt_user  = (0.0, 0.0),
                   e_on         = False,
                   start_e_on   = False,
                   start_e_val  = 0.1,
                   e0_on        = False,
                   trim_dist    = 30.0,
                   min_spacing  = 3.0,
                   auto_start   = False,
                   m30_on       = False):
    extrusion_k = 0.05
    g = ["; *** Generated by STL→G‑code Streamlit Exporter ***", "G21", "G90"]
    if e_on:
        g.append("M83")

    z_max = mesh.bounds[1, 2]
    prev_start_xy = None

    for z in np.arange(z_int, int(z_max) + 1, z_int):
        sec = mesh.section(plane_origin=[0,0,z], plane_normal=[0,0,1])
        if sec is None:
            continue
        slice2D, to3D = sec.to_2D()
        segments = []
        for seg in slice2D.discrete:
            seg = np.array(seg)
            seg3d = (to3D @ np.hstack([seg, np.zeros((len(seg),1)), np.ones((len(seg),1))]).T).T[:, :3]
            segments.append(seg3d)
        if not segments:
            continue

        g.append(f"\n; ---------- Z = {z:.1f} mm ----------")

        if auto_start and prev_start_xy is not None:
            dists = [np.linalg.norm(s[0][:2] - prev_start_xy) for s in segments]
            first_idx = int(np.argmin(dists))
            segments = segments[first_idx:] + segments[:first_idx]
            ref_pt_layer = prev_start_xy
        else:
            ref_pt_layer = np.array(ref_pt_user)

        for i_seg, seg3d in enumerate(segments):
            shifted, _  = shift_to_nearest_start(seg3d, ref_pt_layer)
            trimmed     = trim_segment_end(shifted, trim_dist)
            simplified  = simplify_segment(trimmed, min_spacing)
            start       = simplified[0]

            g.append(f"G01 F{feed}")
            if start_e_on:
                g.append(f"G01 X{start[0]:.3f} Y{start[1]:.3f} Z{z:.3f} E{start_e_val:.5f}")
            else:
                g.append(f"G01 X{start[0]:.3f} Y{start[1]:.3f} Z{z:.3f}")

            for p1, p2 in zip(simplified[:-1], simplified[1:]):
                dist = np.linalg.norm(p2[:2] - p1[:2])
                if e_on:
                    g.append(f"G01 X{p2[0]:.3f} Y{p2[1]:.3f} E{dist * extrusion_k:.5f}")
                else:
                    g.append(f"G01 X{p2[0]:.3f} Y{p2[1]:.3f}")

            if e0_on:
                g.append("G01 E0")

            if i_seg == 0:
                prev_start_xy = start[:2]

    g.append(f"G01 F{feed}")
    if m30_on:
        g.append("M30")
    return "\n".join(g)

st.sidebar.header("⚙️ Parameters")
z_int        = st.sidebar.number_input("Z interval (mm)",  1.0, 1000.0, 30.0)
feed         = st.sidebar.number_input("Feedrate (F)",     1,    100000, 2000)
ref_x        = st.sidebar.number_input("Reference X",      value=0.0)
ref_y        = st.sidebar.number_input("Reference Y",      value=0.0)

st.sidebar.subheader("Extrusion options")
e_on         = st.sidebar.checkbox("Insert E values")
start_e_on   = st.sidebar.checkbox("E value at loop start", value=False, disabled=not e_on)
start_e_val  = st.sidebar.number_input("Start E value", value=0.1, disabled=not (e_on and start_e_on))
e0_on        = st.sidebar.checkbox("Add E0 at loop end", value=False, disabled=not e_on)

st.sidebar.subheader("Path processing")
trim_dist    = st.sidebar.number_input("Trim/nozzle radius (mm)", 0.0, 1000.0, 30.0)
min_spacing  = st.sidebar.number_input("Minimum point spacing (mm)", 0.0, 1000.0, 3.0)
auto_start   = st.sidebar.checkbox("Start next layer near previous start")
m30_on       = st.sidebar.checkbox("Append M30 at end", value=False)

st.sidebar.markdown("---")

uploaded = st.file_uploader("📂 Upload STL", type=["stl"])
if uploaded is not None:
    with tempfile.NamedTemporaryFile(delete=False, suffix=".stl") as tmp:
        tmp.write(uploaded.read())
        tmp_path = tmp.name

    try:
        mesh = trimesh.load_mesh(tmp_path)
        st.success("STL loaded successfully ✅")
    except Exception as e:
        st.error(f"Failed to load STL: {e}")
        st.stop()

    if st.button("🚀 Generate G‑code"):
        with st.spinner("Processing..."):
            gcode_text = generate_gcode(
                mesh,
                z_int = z_int,
                feed = feed,
                ref_pt_user = (ref_x, ref_y),
                e_on = e_on,
                start_e_on = start_e_on,
                start_e_val = start_e_val,
                e0_on = e0_on,
                trim_dist = trim_dist,
                min_spacing = min_spacing,
                auto_start = auto_start,
                m30_on = m30_on
            )
        st.success("G‑code generation finished 🎉")
        st.download_button("💾 Download G‑code", gcode_text, file_name="output.gcode", mime="text/plain")

st.markdown("---")
st.caption("© 2025 – STL → G‑code Exporter (Streamlit Edition)")
