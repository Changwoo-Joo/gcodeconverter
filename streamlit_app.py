
import streamlit as st
import numpy as np
import trimesh
import tempfile
import os

PASSWORD = "darobotics*"

# ì¸ì¦ ìƒíƒœë¥¼ session_stateë¡œ ìœ ì§€
if "authenticated" not in st.session_state:
    st.session_state.authenticated = False

if not st.session_state.authenticated:
    st.title("ğŸ”’ ë¹„ë°€ë²ˆí˜¸ ì…ë ¥")
    pwd = st.text_input("ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”", type="password")
    if st.button("ë¡œê·¸ì¸"):
        if pwd == PASSWORD:
            st.session_state.authenticated = True
            st.rerun()
        else:
            st.error("âŒ ë¹„ë°€ë²ˆí˜¸ê°€ í‹€ë ¸ìŠµë‹ˆë‹¤.")
    st.stop()

st.title("ğŸ› ï¸ STL â†’ Gâ€‘code ì»¨ë²„í„°")
st.markdown("""STLíŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”. ì¢Œì¸¡ íŒŒë¼ë¯¸í„°ì—ì„œ Zê°’ê³¼ ì†ë„, ì‹œì‘ì ì„ ì§€ì •í•´ì£¼ì„¸ìš”. ì˜µì…˜ì„ ì§€ì •í•˜ë©´ ì§€ì •ëœ ì˜µì…˜ì— ë”°ë¼ ê²½ë¡œê°€ ìƒì„±ë©ë‹ˆë‹¤. ê¶ê¸ˆí•˜ì‹  ì‚¬í•­ì€ ë™ì•„ë¡œë³´í‹±ìŠ¤ ê¸°ìˆ ì—°êµ¬ì†Œ ì£¼ì°½ìš°ë¶€ì¥(010-6754-2575)ë¡œ ì—°ë½í•´ì£¼ì„¸ìš”.""")

def trim_segment_end(segment, trim_distance=30.0):
    segment = np.array(segment)
    total_len = np.sum(np.linalg.norm(np.diff(segment, axis=0), axis=1))
    if total_len <= trim_distance:
        return segment
    trimmed = [segment[0]]
    acc = 0.0
    for i in range(1, len(segment)):
        p1, p2 = segment[i - 1], segment[i]
        d = np.linalg.norm(p2 - p1)
        if acc + d >= total_len - trim_distance:
            r = (total_len - trim_distance - acc) / d
            trimmed.append(p1 + (p2 - p1) * r)
            break
        trimmed.append(p2)
        acc += d
    return np.array(trimmed)

def simplify_segment(segment, min_dist):
    simplified = [segment[0]]
    for pt in segment[1:-1]:
        if np.linalg.norm(pt[:2] - simplified[-1][:2]) >= min_dist:
            simplified.append(pt)
    simplified.append(segment[-1])
    return np.array(simplified)

def shift_to_nearest_start(segment, ref_point):
    idx = np.argmin(np.linalg.norm(segment[:, :2] - ref_point, axis=1))
    return np.concatenate([segment[idx:], segment[1:idx + 1]], axis=0), segment[idx]

def generate_gcode(mesh,
                   z_int        = 30.0,
                   feed         = 2000,
                   ref_pt_user  = (0.0, 0.0),
                   e_on         = False,
                   start_e_on   = False,
                   start_e_val  = 0.1,
                   e0_on        = False,
                   trim_dist    = 30.0,
                   min_spacing  = 3.0,
                   auto_start   = False,
                   m30_on       = False):
    extrusion_k = 0.05
    g = ["; *** Generated by STLâ†’Gâ€‘code Streamlit Exporter ***", "G21", "G90"]
    if e_on:
        g.append("M83")

    z_max = mesh.bounds[1, 2]
    prev_start_xy = None

    for z in np.arange(z_int, int(z_max) + 1, z_int):
        sec = mesh.section(plane_origin=[0,0,z], plane_normal=[0,0,1])
        if sec is None:
            continue
        slice2D, to3D = sec.to_2D()
        segments = []
        for seg in slice2D.discrete:
            seg = np.array(seg)
            seg3d = (to3D @ np.hstack([seg, np.zeros((len(seg),1)), np.ones((len(seg),1))]).T).T[:, :3]
            segments.append(seg3d)
        if not segments:
            continue

        g.append(f"\n; ---------- Z = {z:.1f} mm ----------")

        if auto_start and prev_start_xy is not None:
            dists = [np.linalg.norm(s[0][:2] - prev_start_xy) for s in segments]
            first_idx = int(np.argmin(dists))
            segments = segments[first_idx:] + segments[:first_idx]
            ref_pt_layer = prev_start_xy
        else:
            ref_pt_layer = np.array(ref_pt_user)

        for i_seg, seg3d in enumerate(segments):
            shifted, _  = shift_to_nearest_start(seg3d, ref_pt_layer)
            trimmed     = trim_segment_end(shifted, trim_dist)
            simplified  = simplify_segment(trimmed, min_spacing)
            start       = simplified[0]

            g.append(f"G01 F{feed}")
            if start_e_on:
                g.append(f"G01 X{start[0]:.3f} Y{start[1]:.3f} Z{z:.3f} E{start_e_val:.5f}")
            else:
                g.append(f"G01 X{start[0]:.3f} Y{start[1]:.3f} Z{z:.3f}")

            for p1, p2 in zip(simplified[:-1], simplified[1:]):
                dist = np.linalg.norm(p2[:2] - p1[:2])
                if e_on:
                    g.append(f"G01 X{p2[0]:.3f} Y{p2[1]:.3f} E{dist * extrusion_k:.5f}")
                else:
                    g.append(f"G01 X{p2[0]:.3f} Y{p2[1]:.3f}")

            if e0_on:
                g.append("G01 E0")

            if i_seg == 0:
                prev_start_xy = start[:2]

    g.append(f"G01 F{feed}")
    if m30_on:
        g.append("M30")
    return "\n".join(g)

st.sidebar.header("âš™ï¸ Parameters")
z_int        = st.sidebar.number_input("Z interval (mm)",  1.0, 1000.0, 30.0)
feed         = st.sidebar.number_input("Feedrate (F)",     1,    100000, 2000)
ref_x        = st.sidebar.number_input("Reference X",      value=0.0)
ref_y        = st.sidebar.number_input("Reference Y",      value=0.0)

st.sidebar.subheader("Extrusion options")
e_on         = st.sidebar.checkbox("Insert E values")
start_e_on   = st.sidebar.checkbox("Continuous Layer Printing", value=False, disabled=not e_on)
start_e_val  = st.sidebar.number_input("Start E value", value=0.1, disabled=not (e_on and start_e_on))
e0_on        = st.sidebar.checkbox("Add E0 at loop end", value=False, disabled=not e_on)

st.sidebar.subheader("Path processing")
trim_dist    = st.sidebar.number_input("Trim/Layer Radius (mm)", 0.0, 1000.0, 30.0)
min_spacing  = st.sidebar.number_input("Minimum point spacing (mm)", 0.0, 1000.0, 3.0)
auto_start   = st.sidebar.checkbox("Start next layer near previous start")
m30_on       = st.sidebar.checkbox("Append M30 at end", value=False)

st.sidebar.markdown("---")

uploaded = st.file_uploader("ğŸ“‚ Upload STL", type=["stl"])
if uploaded is not None:
    with tempfile.NamedTemporaryFile(delete=False, suffix=".stl") as tmp:
        tmp.write(uploaded.read())
        tmp_path = tmp.name

    try:
        mesh = trimesh.load_mesh(tmp_path)
        st.success("STL loaded successfully âœ…")
    except Exception as e:
        st.error(f"Failed to load STL: {e}")
        st.stop()

    if st.button("ğŸš€ Generate Gâ€‘code"):
        with st.spinner("Processing..."):
            gcode_text = generate_gcode(
                mesh,
                z_int = z_int,
                feed = feed,
                ref_pt_user = (ref_x, ref_y),
                e_on = e_on,
                start_e_on = start_e_on,
                start_e_val = start_e_val,
                e0_on = e0_on,
                trim_dist = trim_dist,
                min_spacing = min_spacing,
                auto_start = auto_start,
                m30_on = m30_on
            )
        st.success("Gâ€‘code generation finished ğŸ‰")
        st.download_button("ğŸ’¾ Download Gâ€‘code", gcode_text, file_name="output.gcode", mime="text/plain")

st.markdown("---")
st.caption("Â© 2025 â€“ STL â†’ Gâ€‘code Exporter (Streamlit Edition)")
